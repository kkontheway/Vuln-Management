"""Repository functions for vulnerability data access."""
from typing import Dict, List, Optional, Tuple

from app.repositories.query_builder import build_vulnerability_filters
from app.constants.database import TABLE_VULNERABILITIES, TABLE_VULNERABILITY_CATALOG


def get_vulnerabilities(connection, filters=None, page: int = 1, per_page: int = 50, vuln_id: Optional[str] = None) -> Tuple[List[Dict], int]:
    """Fetch vulnerabilities with filters and pagination."""
    cursor = connection.cursor(dictionary=True)
    try:
        where_sql, params = build_vulnerability_filters(filters, vuln_id, table_alias="v")
        count_query = f"SELECT COUNT(*) as total FROM {TABLE_VULNERABILITIES} v WHERE {where_sql}"
        cursor.execute(count_query, params.copy())
        total = cursor.fetchone()['total']
        
        offset = (page - 1) * per_page
        data_query = f"""
        SELECT 
            v.id,
            v.cve_id,
            v.disk_paths,
            v.registry_paths,
            v.device_id,
            v.rbac_group_name,
            v.device_name,
            v.os_platform,
            v.os_version,
            v.os_architecture,
            v.software_vendor,
            v.software_name,
            v.software_version,
            v.vulnerability_severity_level,
            v.recommended_security_update,
            v.recommended_security_update_id,
            v.recommended_security_update_url,
            v.last_seen_timestamp,
            v.first_seen_timestamp,
            v.exploitability_level,
            v.recommendation_reference,
            v.security_update_available,
            v.event_timestamp,
            v.status,
            v.cvss_score,
            v.autopatch_covered,
            v.metasploit_detected,
            v.nuclei_detected,
            v.recordfuture_detected,
            v.last_synced as last_updated,
            catalog.description AS catalog_description,
            catalog.epss AS catalog_epss
        FROM {TABLE_VULNERABILITIES} v
        LEFT JOIN {TABLE_VULNERABILITY_CATALOG} AS catalog
            ON v.cve_id = catalog.cve_id
        WHERE {where_sql}
        ORDER BY cvss_score DESC, last_seen_timestamp DESC
        LIMIT %s OFFSET %s
        """
        data_params = params.copy()
        data_params.extend([per_page, offset])
        cursor.execute(data_query, data_params)
        records = cursor.fetchall()
        return records, total
    finally:
        cursor.close()


def get_severity_stats(connection) -> List[Dict]:
    cursor = connection.cursor(dictionary=True)
    try:
        cursor.execute(f"""
            SELECT 
                vulnerability_severity_level, 
                COUNT(DISTINCT cve_id) as count
            FROM {TABLE_VULNERABILITIES}
            WHERE vulnerability_severity_level IS NOT NULL 
              AND vulnerability_severity_level != ''
              AND cve_id IS NOT NULL
              AND cve_id != ''
            GROUP BY vulnerability_severity_level
        """)
        return cursor.fetchall()
    finally:
        cursor.close()


def get_status_stats(connection) -> List[Dict]:
    cursor = connection.cursor(dictionary=True)
    try:
        cursor.execute(f"""
            SELECT status, COUNT(*) as count
            FROM {TABLE_VULNERABILITIES}
            WHERE status IS NOT NULL
            GROUP BY status
        """)
        return cursor.fetchall()
    finally:
        cursor.close()


def get_platform_stats(connection) -> List[Dict]:
    cursor = connection.cursor(dictionary=True)
    try:
        cursor.execute(f"""
            SELECT 
                os_platform, 
                COUNT(DISTINCT cve_id) as count
            FROM {TABLE_VULNERABILITIES}
            WHERE os_platform IS NOT NULL 
              AND os_platform != ''
              AND cve_id IS NOT NULL
              AND cve_id != ''
            GROUP BY os_platform
            LIMIT 10
        """)
        return cursor.fetchall()
    finally:
        cursor.close()


def get_vendor_stats(connection) -> List[Dict]:
    cursor = connection.cursor(dictionary=True)
    try:
        cursor.execute(f"""
            SELECT software_vendor, COUNT(*) as count
            FROM {TABLE_VULNERABILITIES}
            WHERE software_vendor IS NOT NULL
            GROUP BY software_vendor
            ORDER BY count DESC
            LIMIT 10
        """)
        return cursor.fetchall()
    finally:
        cursor.close()


def get_exploitability_stats(connection) -> List[Dict]:
    cursor = connection.cursor(dictionary=True)
    try:
        cursor.execute(f"""
            SELECT exploitability_level, COUNT(*) as count
            FROM {TABLE_VULNERABILITIES}
            WHERE exploitability_level IS NOT NULL
            GROUP BY exploitability_level
        """)
        return cursor.fetchall()
    finally:
        cursor.close()


def get_age_distribution(connection) -> List[Dict]:
    cursor = connection.cursor(dictionary=True)
    try:
        cursor.execute(f"""
            SELECT 
                CASE 
                    WHEN DATEDIFF(NOW(), COALESCE(earliest_first_seen, NOW())) < 30 THEN '< 30天'
                    WHEN DATEDIFF(NOW(), COALESCE(earliest_first_seen, NOW())) <= 60 THEN '30-60天'
                    WHEN DATEDIFF(NOW(), COALESCE(earliest_first_seen, NOW())) <= 90 THEN '60-90天'
                    ELSE '> 90天'
                END as age_range,
                CASE 
                    WHEN has_critical > 0 THEN 'Critical'
                    WHEN has_high > 0 THEN 'High'
                    WHEN has_medium > 0 THEN 'Medium'
                    WHEN has_low > 0 THEN 'Low'
                    ELSE 'Other'
                END as severity_level,
                COUNT(*) as count
            FROM (
                SELECT 
                    cve_id,
                    MIN(first_seen_timestamp) as earliest_first_seen,
                    SUM(CASE WHEN vulnerability_severity_level LIKE '%1 - Critical%' OR vulnerability_severity_level LIKE '%Critical%' THEN 1 ELSE 0 END) as has_critical,
                    SUM(CASE WHEN vulnerability_severity_level LIKE '%2 - High%' OR vulnerability_severity_level LIKE '%High%' THEN 1 ELSE 0 END) as has_high,
                    SUM(CASE WHEN vulnerability_severity_level LIKE '%3 - Medium%' OR vulnerability_severity_level LIKE '%Medium%' THEN 1 ELSE 0 END) as has_medium,
                    SUM(CASE WHEN vulnerability_severity_level LIKE '%4 - Low%' OR vulnerability_severity_level LIKE '%Low%' THEN 1 ELSE 0 END) as has_low
                FROM {TABLE_VULNERABILITIES}
                WHERE vulnerability_severity_level IS NOT NULL 
                  AND vulnerability_severity_level != ''
                  AND cve_id IS NOT NULL
                  AND cve_id != ''
                GROUP BY cve_id
            ) as cve_summary
            GROUP BY age_range, severity_level
            ORDER BY 
                CASE age_range
                    WHEN '< 30天' THEN 1
                    WHEN '30-60天' THEN 2
                    WHEN '60-90天' THEN 3
                    WHEN '> 90天' THEN 4
                END,
                CASE severity_level
                    WHEN 'Critical' THEN 1
                    WHEN 'High' THEN 2
                    WHEN 'Medium' THEN 3
                    WHEN 'Low' THEN 4
                    ELSE 5
                END
        """)
        return cursor.fetchall()
    finally:
        cursor.close()


def get_exploitability_ratio(connection) -> List[Dict]:
    cursor = connection.cursor(dictionary=True)
    try:
        cursor.execute(f"""
            SELECT 
                CASE 
                    WHEN exploitability_level IS NOT NULL AND exploitability_level != '' THEN 'Exploitable'
                    ELSE 'Theoretical'
                END as exploitability_status,
                COUNT(DISTINCT cve_id) as count
            FROM {TABLE_VULNERABILITIES}
            WHERE cve_id IS NOT NULL AND cve_id != ''
            GROUP BY exploitability_status
        """)
        return cursor.fetchall()
    finally:
        cursor.close()


def get_autopatch_coverage(connection) -> List[Dict]:
    cursor = connection.cursor(dictionary=True)
    try:
        cursor.execute(f"""
            SELECT 
                CASE 
                    WHEN vulnerability_severity_level LIKE '%1 - Critical%' OR vulnerability_severity_level LIKE '%Critical%' THEN 'Critical'
                    WHEN vulnerability_severity_level LIKE '%2 - High%' OR vulnerability_severity_level LIKE '%High%' THEN 'High'
                    WHEN vulnerability_severity_level LIKE '%3 - Medium%' OR vulnerability_severity_level LIKE '%Medium%' THEN 'Medium'
                    ELSE NULL
                END as severity,
                autopatch_covered,
                COUNT(DISTINCT cve_id) as count
            FROM {TABLE_VULNERABILITIES}
            WHERE cve_id IS NOT NULL 
              AND cve_id != ''
              AND (
                vulnerability_severity_level LIKE '%Critical%' 
                OR vulnerability_severity_level LIKE '%High%' 
                OR vulnerability_severity_level LIKE '%Medium%'
              )
            GROUP BY severity, autopatch_covered
            HAVING severity IS NOT NULL
        """)
        return cursor.fetchall()
    finally:
        cursor.close()


def get_new_vulnerabilities_count(connection, days: int = 7) -> int:
    cursor = connection.cursor(dictionary=True)
    try:
        cursor.execute(f"""
            SELECT COUNT(*) as count
            FROM (
                SELECT 
                    cve_id,
                    MIN(first_seen_timestamp) AS first_seen
                FROM {TABLE_VULNERABILITIES}
                WHERE first_seen_timestamp IS NOT NULL
                  AND cve_id IS NOT NULL 
                  AND cve_id != ''
                GROUP BY cve_id
                HAVING first_seen >= DATE_SUB(NOW(), INTERVAL %s DAY)
            ) recent_cves
        """, (days,))
        result = cursor.fetchone()
        return result['count'] if result else 0
    finally:
        cursor.close()


def get_epss_distribution(connection) -> List[Dict]:
    """Aggregate Defender catalog entries into EPSS risk buckets."""
    cursor = connection.cursor(dictionary=True)
    try:
        cursor.execute(
            f"""
            SELECT bucket, COUNT(*) AS count
            FROM (
                SELECT 
                    cve_id,
                    CASE
                        WHEN epss >= 0.90 THEN 'Critical (>0.90)'
                        WHEN epss >= 0.80 THEN 'High (0.8-0.90)'
                        WHEN epss >= 0.50 THEN 'Medium (0.5-0.8)'
                        ELSE 'Low (0-0.5)'
                    END AS bucket
                FROM {TABLE_VULNERABILITY_CATALOG}
                WHERE epss IS NOT NULL
            ) AS bucketed
            GROUP BY bucket
            """
        )
        return cursor.fetchall()
    finally:
        cursor.close()


def get_intelligence_feed_overlap(connection) -> Dict[str, int]:
    cursor = connection.cursor(dictionary=True)
    try:
        cursor.execute(
            f"""
            SELECT
                SUM(CASE WHEN nuclei_hit = 1 AND metasploit_hit = 0 AND recordfuture_hit = 0 THEN 1 ELSE 0 END) AS nuclei_only,
                SUM(CASE WHEN metasploit_hit = 1 AND nuclei_hit = 0 AND recordfuture_hit = 0 THEN 1 ELSE 0 END) AS metasploit_only,
                SUM(CASE WHEN recordfuture_hit = 1 AND nuclei_hit = 0 AND metasploit_hit = 0 THEN 1 ELSE 0 END) AS recordfuture_only,
                SUM(CASE WHEN (
                        (nuclei_hit = 1 AND metasploit_hit = 1 AND recordfuture_hit = 0)
                        OR (nuclei_hit = 1 AND recordfuture_hit = 1 AND metasploit_hit = 0)
                        OR (metasploit_hit = 1 AND recordfuture_hit = 1 AND nuclei_hit = 0)
                    ) THEN 1 ELSE 0 END) AS two_feeds,
                SUM(CASE WHEN nuclei_hit = 1 AND metasploit_hit = 1 AND recordfuture_hit = 1 THEN 1 ELSE 0 END) AS three_feeds
            FROM (
                SELECT
                    cve_id,
                    MAX(CASE WHEN COALESCE(nuclei_detected, 0) = 1 THEN 1 ELSE 0 END) AS nuclei_hit,
                    MAX(CASE WHEN COALESCE(metasploit_detected, 0) = 1 THEN 1 ELSE 0 END) AS metasploit_hit,
                    MAX(CASE WHEN COALESCE(recordfuture_detected, 0) = 1 THEN 1 ELSE 0 END) AS recordfuture_hit
                FROM {TABLE_VULNERABILITIES}
                WHERE cve_id IS NOT NULL AND cve_id != ''
                GROUP BY cve_id
            ) AS detection
            """
        )
        result = cursor.fetchone() or {}
        return {
            'nuclei_only': result.get('nuclei_only', 0) or 0,
            'metasploit_only': result.get('metasploit_only', 0) or 0,
            'recordfuture_only': result.get('recordfuture_only', 0) or 0,
            'two_feeds': result.get('two_feeds', 0) or 0,
            'three_feeds': result.get('three_feeds', 0) or 0,
        }
    finally:
        cursor.close()


def get_vulnerability_catalog_entry(connection, cve_id: str) -> Optional[Dict]:
    cursor = connection.cursor(dictionary=True)
    try:
        cursor.execute(
            f"""
            SELECT 
                cve_id,
                name,
                description,
                severity,
                cvss_v3,
                cvss_vector,
                exposed_machines,
                public_exploit,
                exploit_verified,
                exploit_in_kit,
                epss,
                published_on,
                updated_on
            FROM {TABLE_VULNERABILITY_CATALOG}
            WHERE cve_id = %s
            LIMIT 1
            """,
            (cve_id,)
        )
        return cursor.fetchone()
    finally:
        cursor.close()
