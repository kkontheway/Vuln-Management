"""Repository functions for vulnerability data access."""
from typing import Dict, List, Optional, Tuple

from app.repositories.query_builder import build_vulnerability_filters
from app.constants.database import TABLE_VULNERABILITIES


def get_vulnerabilities(connection, filters=None, page: int = 1, per_page: int = 50, vuln_id: Optional[str] = None) -> Tuple[List[Dict], int]:
    """Fetch CVE-level vulnerability summaries with filters and pagination."""
    cursor = connection.cursor(dictionary=True)
    try:
        where_sql, params = build_vulnerability_filters(filters, vuln_id, table_alias="v")
        count_query = f"SELECT COUNT(DISTINCT v.cve_id) as total FROM {TABLE_VULNERABILITIES} v WHERE {where_sql}"
        cursor.execute(count_query, params.copy())
        total = cursor.fetchone()['total']

        offset = (page - 1) * per_page
        summary_query = f"""
        SELECT
            MIN(v.id) AS id,
            v.cve_id,
            MAX(v.vulnerability_severity_level) AS severity,
            MAX(v.cvss_score) AS cvss_score,
            MAX(v.cve_epss) AS cve_epss,
            MAX(COALESCE(v.cve_public_exploit, 0)) AS cve_public_exploit,
            MAX(v.status) AS status,
            MAX(v.os_platform) AS os_platform,
            MAX(v.software_name) AS software_name,
            SUM(CASE WHEN COALESCE(v.metasploit_detected, 0) = 1 THEN 1 ELSE 0 END) > 0 AS metasploit_detected,
            SUM(CASE WHEN COALESCE(v.nuclei_detected, 0) = 1 THEN 1 ELSE 0 END) > 0 AS nuclei_detected,
            SUM(CASE WHEN COALESCE(v.recordfuture_detected, 0) = 1 THEN 1 ELSE 0 END) > 0 AS recordfuture_detected,
            COUNT(DISTINCT v.device_id) AS affected_devices,
            MAX(v.last_seen_timestamp) AS last_seen_timestamp
        FROM {TABLE_VULNERABILITIES} v
        WHERE {where_sql}
        GROUP BY v.cve_id
        ORDER BY MAX(v.cvss_score) DESC, MAX(v.last_seen_timestamp) DESC
        LIMIT %s OFFSET %s
        """
        data_params = params.copy()
        data_params.extend([per_page, offset])
        cursor.execute(summary_query, data_params)
        records = cursor.fetchall()
        return records, total
    finally:
        cursor.close()


def get_patchthis_vulnerabilities(connection, limit: int = 20) -> List[Dict]:
    cursor = connection.cursor(dictionary=True)
    try:
        cursor.execute(
            f"""
            SELECT
                MIN(v.id) AS id,
                v.cve_id,
                MAX(v.vulnerability_severity_level) AS severity,
                MAX(v.cvss_score) AS cvss_score,
                MAX(v.cve_epss) AS cve_epss,
                MAX(COALESCE(v.cve_public_exploit, 0)) AS cve_public_exploit,
                MAX(v.status) AS status,
                MAX(v.os_platform) AS os_platform,
                MAX(v.software_name) AS software_name,
                MAX(v.exploitability_level) AS exploitability_level,
                SUM(CASE WHEN COALESCE(v.metasploit_detected, 0) = 1 THEN 1 ELSE 0 END) > 0 AS metasploit_detected,
                SUM(CASE WHEN COALESCE(v.nuclei_detected, 0) = 1 THEN 1 ELSE 0 END) > 0 AS nuclei_detected,
                SUM(CASE WHEN COALESCE(v.recordfuture_detected, 0) = 1 THEN 1 ELSE 0 END) > 0 AS recordfuture_detected,
                COUNT(DISTINCT v.device_id) AS affected_devices,
                MAX(v.last_seen_timestamp) AS last_seen_timestamp
            FROM {TABLE_VULNERABILITIES} v
            WHERE (
                COALESCE(v.cve_public_exploit, 0) = 1
                OR COALESCE(v.metasploit_detected, 0) = 1
                OR COALESCE(v.nuclei_detected, 0) = 1
                OR COALESCE(v.recordfuture_detected, 0) = 1
                OR COALESCE(v.cve_epss, 0) > 0.90
                OR (v.exploitability_level IS NOT NULL AND v.exploitability_level != '' AND v.exploitability_level LIKE '%Active%')
            )
            GROUP BY v.cve_id
            ORDER BY
                MAX(v.cvss_score) DESC,
                MAX(v.cve_epss) DESC,
                MAX(v.last_seen_timestamp) DESC
            LIMIT %s
            """,
            (limit,)
        )
        return cursor.fetchall()
    finally:
        cursor.close()


def get_severity_stats(connection) -> List[Dict]:
    cursor = connection.cursor(dictionary=True)
    try:
        cursor.execute(f"""
            SELECT 
                vulnerability_severity_level, 
                COUNT(DISTINCT cve_id) as count
            FROM {TABLE_VULNERABILITIES}
            WHERE vulnerability_severity_level IS NOT NULL 
              AND vulnerability_severity_level != ''
              AND cve_id IS NOT NULL
              AND cve_id != ''
            GROUP BY vulnerability_severity_level
        """)
        return cursor.fetchall()
    finally:
        cursor.close()


def get_status_stats(connection) -> List[Dict]:
    cursor = connection.cursor(dictionary=True)
    try:
        cursor.execute(f"""
            SELECT status, COUNT(*) as count
            FROM {TABLE_VULNERABILITIES}
            WHERE status IS NOT NULL
            GROUP BY status
        """)
        return cursor.fetchall()
    finally:
        cursor.close()


def get_platform_stats(connection) -> List[Dict]:
    cursor = connection.cursor(dictionary=True)
    try:
        cursor.execute(f"""
            SELECT 
                os_platform, 
                COUNT(DISTINCT cve_id) as count
            FROM {TABLE_VULNERABILITIES}
            WHERE os_platform IS NOT NULL 
              AND os_platform != ''
              AND cve_id IS NOT NULL
              AND cve_id != ''
            GROUP BY os_platform
            LIMIT 10
        """)
        return cursor.fetchall()
    finally:
        cursor.close()


def get_vendor_stats(connection) -> List[Dict]:
    cursor = connection.cursor(dictionary=True)
    try:
        cursor.execute(f"""
            SELECT software_vendor, COUNT(*) as count
            FROM {TABLE_VULNERABILITIES}
            WHERE software_vendor IS NOT NULL
            GROUP BY software_vendor
            ORDER BY count DESC
            LIMIT 10
        """)
        return cursor.fetchall()
    finally:
        cursor.close()


def get_exploitability_stats(connection) -> List[Dict]:
    cursor = connection.cursor(dictionary=True)
    try:
        cursor.execute(f"""
            SELECT exploitability_level, COUNT(*) as count
            FROM {TABLE_VULNERABILITIES}
            WHERE exploitability_level IS NOT NULL
            GROUP BY exploitability_level
        """)
        return cursor.fetchall()
    finally:
        cursor.close()


def get_age_distribution(connection) -> List[Dict]:
    cursor = connection.cursor(dictionary=True)
    try:
        cursor.execute(f"""
            SELECT 
                CASE 
                    WHEN DATEDIFF(NOW(), COALESCE(earliest_first_seen, NOW())) < 30 THEN '< 30天'
                    WHEN DATEDIFF(NOW(), COALESCE(earliest_first_seen, NOW())) <= 60 THEN '30-60天'
                    WHEN DATEDIFF(NOW(), COALESCE(earliest_first_seen, NOW())) <= 90 THEN '60-90天'
                    ELSE '> 90天'
                END as age_range,
                CASE 
                    WHEN has_critical > 0 THEN 'Critical'
                    WHEN has_high > 0 THEN 'High'
                    WHEN has_medium > 0 THEN 'Medium'
                    WHEN has_low > 0 THEN 'Low'
                    ELSE 'Other'
                END as severity_level,
                COUNT(*) as count
            FROM (
                SELECT 
                    cve_id,
                    MIN(first_seen_timestamp) as earliest_first_seen,
                    SUM(CASE WHEN vulnerability_severity_level LIKE '%1 - Critical%' OR vulnerability_severity_level LIKE '%Critical%' THEN 1 ELSE 0 END) as has_critical,
                    SUM(CASE WHEN vulnerability_severity_level LIKE '%2 - High%' OR vulnerability_severity_level LIKE '%High%' THEN 1 ELSE 0 END) as has_high,
                    SUM(CASE WHEN vulnerability_severity_level LIKE '%3 - Medium%' OR vulnerability_severity_level LIKE '%Medium%' THEN 1 ELSE 0 END) as has_medium,
                    SUM(CASE WHEN vulnerability_severity_level LIKE '%4 - Low%' OR vulnerability_severity_level LIKE '%Low%' THEN 1 ELSE 0 END) as has_low
                FROM {TABLE_VULNERABILITIES}
                WHERE vulnerability_severity_level IS NOT NULL 
                  AND vulnerability_severity_level != ''
                  AND cve_id IS NOT NULL
                  AND cve_id != ''
                GROUP BY cve_id
            ) as cve_summary
            GROUP BY age_range, severity_level
            ORDER BY 
                CASE age_range
                    WHEN '< 30天' THEN 1
                    WHEN '30-60天' THEN 2
                    WHEN '60-90天' THEN 3
                    WHEN '> 90天' THEN 4
                END,
                CASE severity_level
                    WHEN 'Critical' THEN 1
                    WHEN 'High' THEN 2
                    WHEN 'Medium' THEN 3
                    WHEN 'Low' THEN 4
                    ELSE 5
                END
        """)
        return cursor.fetchall()
    finally:
        cursor.close()


def get_exploitability_ratio(connection) -> List[Dict]:
    cursor = connection.cursor(dictionary=True)
    try:
        cursor.execute(f"""
            SELECT 
                CASE 
                    WHEN exploitability_level IS NOT NULL AND exploitability_level != '' THEN 'Exploitable'
                    ELSE 'Theoretical'
                END as exploitability_status,
                COUNT(DISTINCT cve_id) as count
            FROM {TABLE_VULNERABILITIES}
            WHERE cve_id IS NOT NULL AND cve_id != ''
            GROUP BY exploitability_status
        """)
        return cursor.fetchall()
    finally:
        cursor.close()


def get_autopatch_coverage(connection) -> List[Dict]:
    cursor = connection.cursor(dictionary=True)
    try:
        cursor.execute(f"""
            SELECT 
                CASE 
                    WHEN vulnerability_severity_level LIKE '%1 - Critical%' OR vulnerability_severity_level LIKE '%Critical%' THEN 'Critical'
                    WHEN vulnerability_severity_level LIKE '%2 - High%' OR vulnerability_severity_level LIKE '%High%' THEN 'High'
                    WHEN vulnerability_severity_level LIKE '%3 - Medium%' OR vulnerability_severity_level LIKE '%Medium%' THEN 'Medium'
                    ELSE NULL
                END as severity,
                autopatch_covered,
                COUNT(DISTINCT cve_id) as count
            FROM {TABLE_VULNERABILITIES}
            WHERE cve_id IS NOT NULL 
              AND cve_id != ''
              AND (
                vulnerability_severity_level LIKE '%Critical%' 
                OR vulnerability_severity_level LIKE '%High%' 
                OR vulnerability_severity_level LIKE '%Medium%'
              )
            GROUP BY severity, autopatch_covered
            HAVING severity IS NOT NULL
        """)
        return cursor.fetchall()
    finally:
        cursor.close()


def get_new_vulnerabilities_count(connection, days: int = 7) -> int:
    cursor = connection.cursor(dictionary=True)
    try:
        cursor.execute(f"""
            SELECT COUNT(*) as count
            FROM (
                SELECT 
                    cve_id,
                    MIN(first_seen_timestamp) AS first_seen
                FROM {TABLE_VULNERABILITIES}
                WHERE first_seen_timestamp IS NOT NULL
                  AND cve_id IS NOT NULL 
                  AND cve_id != ''
                GROUP BY cve_id
                HAVING first_seen >= DATE_SUB(NOW(), INTERVAL %s DAY)
            ) recent_cves
        """, (days,))
        result = cursor.fetchone()
        return result['count'] if result else 0
    finally:
        cursor.close()


def get_epss_distribution(connection) -> List[Dict]:
    """Aggregate unique CVEs into EPSS risk buckets."""
    cursor = connection.cursor(dictionary=True)
    try:
        cursor.execute(
            f"""
            SELECT bucket, COUNT(*) AS count
            FROM (
                SELECT 
                    cve_id,
                    CASE
                        WHEN epss >= 0.90 THEN 'Critical (>0.90)'
                        WHEN epss >= 0.80 THEN 'High (0.8-0.90)'
                        WHEN epss >= 0.50 THEN 'Medium (0.5-0.8)'
                        ELSE 'Low (0-0.5)'
                    END AS bucket
                FROM (
                    SELECT cve_id, MAX(cve_epss) AS epss
                    FROM {TABLE_VULNERABILITIES}
                    WHERE cve_id IS NOT NULL
                      AND cve_id != ''
                      AND cve_epss IS NOT NULL
                    GROUP BY cve_id
                ) unique_epss
            ) AS bucketed
            GROUP BY bucket
            """
        )
        return cursor.fetchall()
    finally:
        cursor.close()


def get_intelligence_feed_overlap(connection) -> Dict[str, int]:
    cursor = connection.cursor(dictionary=True)
    try:
        cursor.execute(
            f"""
            SELECT
                SUM(CASE WHEN nuclei_hit = 1 AND metasploit_hit = 0 AND recordfuture_hit = 0 THEN 1 ELSE 0 END) AS nuclei_only,
                SUM(CASE WHEN metasploit_hit = 1 AND nuclei_hit = 0 AND recordfuture_hit = 0 THEN 1 ELSE 0 END) AS metasploit_only,
                SUM(CASE WHEN recordfuture_hit = 1 AND nuclei_hit = 0 AND metasploit_hit = 0 THEN 1 ELSE 0 END) AS recordfuture_only,
                SUM(CASE WHEN (
                        (nuclei_hit = 1 AND metasploit_hit = 1 AND recordfuture_hit = 0)
                        OR (nuclei_hit = 1 AND recordfuture_hit = 1 AND metasploit_hit = 0)
                        OR (metasploit_hit = 1 AND recordfuture_hit = 1 AND nuclei_hit = 0)
                    ) THEN 1 ELSE 0 END) AS two_feeds,
                SUM(CASE WHEN nuclei_hit = 1 AND metasploit_hit = 1 AND recordfuture_hit = 1 THEN 1 ELSE 0 END) AS three_feeds
            FROM (
                SELECT
                    cve_id,
                    MAX(CASE WHEN COALESCE(nuclei_detected, 0) = 1 THEN 1 ELSE 0 END) AS nuclei_hit,
                    MAX(CASE WHEN COALESCE(metasploit_detected, 0) = 1 THEN 1 ELSE 0 END) AS metasploit_hit,
                    MAX(CASE WHEN COALESCE(recordfuture_detected, 0) = 1 THEN 1 ELSE 0 END) AS recordfuture_hit
                FROM {TABLE_VULNERABILITIES}
                WHERE cve_id IS NOT NULL AND cve_id != ''
                GROUP BY cve_id
            ) AS detection
            """
        )
        result = cursor.fetchone() or {}
        return {
            'nuclei_only': result.get('nuclei_only', 0) or 0,
            'metasploit_only': result.get('metasploit_only', 0) or 0,
            'recordfuture_only': result.get('recordfuture_only', 0) or 0,
            'two_feeds': result.get('two_feeds', 0) or 0,
            'three_feeds': result.get('three_feeds', 0) or 0,
        }
    finally:
        cursor.close()


def get_vulnerability_catalog_entry(connection, cve_id: str) -> Optional[Dict]:
    """Fetch summarized vulnerability info from the main table for detail view."""
    cursor = connection.cursor(dictionary=True)
    try:
        cursor.execute(
            f"""
            SELECT 
                cve_id,
                MAX(vulnerability_severity_level) AS severity,
                MAX(cvss_score) AS cvss_v3,
                MAX(cve_epss) AS epss,
                MAX(COALESCE(cve_public_exploit, 0)) AS cve_public_exploit,
                COUNT(DISTINCT device_id) AS affected_devices,
                MAX(last_seen_timestamp) AS last_seen_timestamp
            FROM {TABLE_VULNERABILITIES}
            WHERE cve_id = %s
              AND cve_id IS NOT NULL
              AND cve_id != ''
            GROUP BY cve_id
            LIMIT 1
            """,
            (cve_id,)
        )
        return cursor.fetchone()
    finally:
        cursor.close()


def get_devices_for_cve(connection, cve_id: str) -> List[Dict]:
    """Fetch device-level details for a specific CVE."""
    cursor = connection.cursor(dictionary=True)
    try:
        cursor.execute(
            f"""
            SELECT
                device_id,
                device_name,
                rbac_group_name,
                os_platform,
                os_version,
                os_architecture,
                status,
                last_seen_timestamp
            FROM {TABLE_VULNERABILITIES}
            WHERE cve_id = %s
            ORDER BY last_seen_timestamp DESC
            """,
            (cve_id,)
        )
        return cursor.fetchall()
    finally:
        cursor.close()
